# clang sort of works:
#   - In /usr/lb64/ I needed to: ln -s libgcc_s-5.1.1-20150618.so.1 libgcc_s.so
#   - Needs -Wno-missing-field-initializers because { 0 } initialers don't work on union structs.
#CC = clang
#CFLAGS = -g -O0 -Wall -W -Wextra -pedantic -Wno-missing-field-initializers

CC = gcc
CFLAGS = -g -O0 -Wall -W -Wextra -pedantic

#CFLAGS = -DNDEBUG

LDFLAGS = -ltar -lz

OBJS = grammar.o libje.c parse.o persist.o token.o info.o inbuf.o dispatch.o dumpg.o list.o hash.o sameas.o pattern.o emit.o emit_t.o emit_g.o emit_gv.o g.o
HDRS = grammar.h libje.h libje_private.h

all: g grammar.svg test_grammar.g test

g: ${OBJS}

${OBJS}: ${HDRS}

grammar.c: grammar.h

grammar.h grammar.ebnf grammar.gv: grammar.g gacc.sh
	./gacc.sh grammar.g

# grammar.g can be generated by g, but we need to avoid a dependency loop
# and need to allow hand modifications to be made locally and stored in git.
# So here we just check that the output grammar exactly matches the input
.PHONY: test_grammar.g
test_grammar.g: g
	./g -d >test_grammar.g
	diff grammar.g test_grammar.g

grammar.svg: grammar.gv
	dot -Tsvg grammar.gv -o grammar.svg

# The grammar.g file (or g's internal version of it) provides a convenient test graph
# This test processes 1000 copies of the graph to generate some stats
.PHONY: test
test: g
#	(for i in {1..1000}; do ./g -d; done) | ./g -s >/dev/null
	(for i in {1..1000}; do cat ../neo4j/matrix.g; done) | ./g -s >/dev/null
	

clean:
	rm -f ${OBJS} grammar.gv grammar.[ch] grammar.ebnf grammar.gv grammar.svg test_grammar.g
