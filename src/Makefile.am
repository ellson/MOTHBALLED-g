# Process this file with automake to produce Makefile.in

LIBJE_VERSION="0:0:0"

pdfdir = $(pkgdatadir)/doc/pdf
pkgconfigdir = $(libdir)/pkgconfig

LIBS = $(TAR_LIBS) $(Z_LIBS)

pkginclude_HEADERS =\
	context.h \
	dispatch.h \
	emit.h \
	grammar.h \
	hash.h \
	inbuf.h \
	libje.h \
	libje_private.h \
	list.h \
	pattern.h \
	sameas.h \
	token.h

noinst_HEADERS = \
	context.h \
	dispatch.h \
	emit.h \
	grammar.h \
	hash.h \
	inbuf.h \
	libje_private.h \
	list.h \
	pattern.h \
	sameas.h \
	token.h

lib_LTLIBRARIES = libje.la
#pkgconfig_DATA = libje.pc

#man_MANS = libje.3

libje_C_la_SOURCES = \
	grammar.c \
	libje.c \
	parse.c \
	persist.c \
	token.c \
	info.c \
	inbuf.c \
	dispatch.c \
	dumpg.c \
	list.c \
	hash.c \
	sameas.c \
	pattern.c \
	emit.c \
	emit_t.c \
	emit_g.c \
	emit_gv.c 

libje_C_la_LIBADD = 

libje_la_LDFLAGS = -version-info $(GVC_VERSION) -no-undefined
libje_la_SOURCES = $(libje_C_la_SOURCES)
libje_la_LIBADD = $(libje_C_la_LIBADD) 



# clang sort of works:
#   - Needs -Wno-missing-field-initializers because { 0 } initialers don't work on union structs in clang.
CC = clang
CFLAGS = -g -O0 -Wall -W -Wextra -pedantic -Wno-missing-field-initializers

#CC = gcc
#CFLAGS = -g -O0 -Wall -W -Wextra -pedantic

#CFLAGS = -DNDEBUG

LDFLAGS = -ltar -lz

OBJS = grammar.o libje.o parse.o persist.o token.o info.o inbuf.o dispatch.o dumpg.o list.o hash.o sameas.o pattern.o emit.o emit_t.o emit_g.o emit_gv.o g.o
HDRS = context.h dispatch.h emit.h grammar.h hash.h inbuf.h libje.h libje_private.h list.h pattern.h sameas.h token.h

all: g grammar.svg test_grammar.g test

g: ${OBJS}

${OBJS}: ${HDRS}

grammar.c: grammar.h

grammar.h grammar.ebnf grammar.gv: grammar.g gacc.sh
	./gacc.sh grammar.g

# grammar.g can be generated by g, but we need to avoid a dependency loop
# and need to allow hand modifications to be made locally and stored in git.
# So here we just check that the output grammar exactly matches the input
.PHONY: test_grammar.g
test_grammar.g: g
	./g -d >test_grammar.g
	diff grammar.g test_grammar.g

grammar.svg: grammar.gv
	dot -Tsvg grammar.gv -o grammar.svg

# The grammar.g file (or g's internal version of it) provides a convenient test graph
# This test processes 1000 copies of the graph to generate some stats
.PHONY: test
test: g
#	(for i in {1..1000}; do ./g -d; done) | ./g -s >/dev/null
	(for i in {1..1000}; do cat ../neo4j/matrix.g; done) | ./g -s >/dev/null
	

clean:
	rm -f ${OBJS} grammar.gv grammar.[ch] grammar.ebnf grammar.gv grammar.svg test_grammar.g
