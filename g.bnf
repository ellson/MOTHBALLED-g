# A graph structure is built incrementally with a series of <acts>.
# There is no hard start or end.
# Each act operates on a <subject>.  Only the <subject> is essential to an act.

                <act> ::= <action>? <subject> <properties>? <contents>? <term>?

# The default <action> is to add (or add to) a <subject>,   '~' is to delete

             <action> ::= '~'

# The <subject> of an <act> is one or more <obj> or <metaobj>

            <subject> ::= <obj>
                        | <objlist>
                        | <metaobj>

                <obj> ::= <node>
                        | <edge>

            <objlist> ::= '(' <obj>+ ')'

            <metaobj> ::= <nodepattern>
                        | <edgepattern>

# The scope of <metaobj> is the current container.
#
# <metaobj> are stored, and can be deleted, but they are not rendered
# directly. They represent <properties> and <contents> to be
# automatically added to the <obj> of any following <act>.
#
# When the <metaobject> is deleted, no further <obj> are modified,
# but all current modifications from the <metaobj> remain.

        <nodepattern> ::= '*'

        <edgepattern> ::= '<*>'

# Any <subject> can have <properties> which are to be
# added (or deleted) from all the objects implied by the <subject>

# If <value> is not provided then it defaults to aasigning the empty string 

         <properties> ::= '[' <attribute_value>+ ']'

    <attribute_value> ::= <attribute> <value_assign>?

          <attribute> ::= <name_string>

       <value_assign> ::= '=' <value>

              <value> ::= <name_string>
                        | <integer>
                        | <float>
                        | <boolean>

# Any <subject> can have <contents> which are to be
# added (or deleted) from all the objects implied by the <subject>

           <contents> ::= '{' <act>+ '}'

# The <term> is mostly optional since it is rarely needed syntactically,
# it takes two forms:
#    - The first form is just for people that like to end statements
#      with a terminator.
#    - The second form is used when a stream of <acts> stops,
#      to indicate that the last <act> is finished.
#      Normally in a stream, the an <act> is syntactically terminated
#      when the next <act> starts. When the stream stops, there is no next <act>#      and so the last <act> gets stuck; unless forced with the <sync_term>.
# An <EOF> condition on the input filestream is to be implicitly considered
# a <sync_term>.

               <term> ::= <noise_term>
                        | <sync_term>

         <noise_term> ::= ';'

          <sync_term> ::= ';;'


# A <node> can be simple, or multi (think "layers" of node, all in the same
# place, all with the same <properties>, all with the same <contents>)

               <node> ::= <node_name> <disambiguator>?

      <disambiguator> ::= '::' <name_string>

# An <edge> is a relationship between a set of two or more <node>s, or more
# stricly, <port>s. A <port> is a named-place on the outside of a <node>,
# and also, if the <obj> has <contents>, then it is a named-place refered to
# from inside the container.

# If the containing <obj> is a <node>  then the external name is, e.g. "A:w"
# ( the west compass port on node "A" ).  The internal name for that same port 
# is just ":w"
#
# If the containing <obj> is an <edge>  then the external name is the
# <node> at the external end of the <edge>.  The internal name for that
# same port is the 1-based index of the <node> in the containing <edge>'s
# name.  i.e the "leg" number.
# This may seem awkward, but it allows the edge's <content> to be reused
# for multiple edges.
#
# Note that for <edge>s drawn as lines, the internal <port> and the <edge>'s
# endpoint on an external <node>'s <port> are typically not in the same place.  # However, they are logically the same, since the drawing can always be
# distorted so that they are the same point with no change in semantics.

# An <edge> can be simple, or multi (think "parallel" edges, all with the
# same <endpoints> (modulo disambiguation), all with the same <properties>,
# all with the same <contents>)

               <edge> ::= '<' <endpointlist> '>' <disambiguator>?

       <endpointlist> ::= <endpoint> <endpoint>+

           <endpoint> ::= <node_port>
                        | <container_port> 

          <node_port> ::= <node> <port>?

     <container_port> ::= <port>

               <port> ::= ':' <port_name>

# if <port> is not provided for a <node_port> then it defaults to the
# center of the shape, with the line representing the <edge> clipped back
# to the boundary of the shape.

# <port_name> can be: compass points, or leg index,  or cell index.
          <port_name> ::= 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'nw'
                        | <leg_index>
                        | <cell_index>

           <leg_index> ::= <digit>+

          <cell_index> ::= <digit>+ '.' <digit>+

# Finally, <name string> (Note that quoted strings can be empty)

        <name_string> ::= <simple_char>+
                        | ''' <singlequoted_char>* '''
                        | '"' <doublequoted_char>* '"'

        <simple_char> ::= <not_special_char>
                        | <escape> <special_char>
                        | <escape> '''
                        | <escape> '"'
                        | <escape> <escape>

  <singlequoted_char> ::= <not_special_char>
                        | <special_char>
                        | '"'
                        | <escape> '''
                        | <escape> <escape>
                        
  <doublequoted_char> ::= <not_special_char>
                        | <special_char>
                        | '''
                        | <escape> '"'
                        | <escape> <escape>
                        
             <escape> ::= '\'

# Note:  A few <alpha_uppercase> characters, when escaped, are used
# as substitution variables:
#
#  \O is the name of the object
#  \C is the name of the containing object
#
# Any other character that is escaped, but which doesn't normally need
# to be escaped, is taken as itself.

   <not_special_char> ::= <alpha_uppercase>
                        | <alpha_lowercase>
                        | <digit>
                        | '_' | '.'
                        | '-' | '+'
                        | '&' | '^'
                        | '$' | '@'
                        | '!' | '|'
                        | '`' | '?'
                        | '%'

    <alpha_uppercase> ::= A...Z
    <alpha_lowercase> ::= a...z
              <digit> ::= 0...9

       <special_char> ::= <whitespace> | <newline>
                        | '{' | '}'
                        | '(' | ')'
                        | '[' | ']'
                        | '<' | '>'
                        | '~' | '='
                        | ':' | ';'
                        | '/' | '#'
                        | '*'

           <comments> ::= '//' ... EOL
                        | '#' ... EOL
                        | '/*' ... '*/'

# FIXME - additional detail needed for html-like label strings....





