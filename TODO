1. fix elem leaks 
DONE currenly fixed, + added assert to immediately detect new leaks

2. attribute trees,  attribute merging

3. need some kind of print_edge_name
- for compare and for ikea ...
- needs logical space between str elems, and between legs and disambig
-- maybe insert real: < > `

4. breakout PARSE_t from CONTEXT_t
DONE - renamed PARSE_t to THREAD_t and split out SESSION_t

5. common match code for patterns and queries

6. extend match patterns
- currently ABC* matching only
- would be nice to have support for: *ABC   and ABC*XYZ
- can we find a syntax for REs that fits?

7. parent{graph patterns stats cron net...}
DUPLICATE with 16.

8. thread and event model
- parser per thread
- allow multiple ACTIVITY streams per CONTAINER (doact.c mutexes on outacts so as to treated atomically)
- inotify input events
  - on last non-stdin file on command line?
  - on file with special option ?
  - RESTful events on a socket  (push or pull) - a daemon mode
- cron-like:
	 output events e.g. "cron{^/graph[full=nowtime%3600 diff=nowtime%5]}"
-        input polling events, ....
         access verication...

- gdiff - for incremental outputs

9. queries
- results return to same bidir channel (RESTfull, socket, stdio, 
            -- what about queries in files??? 
                     -- maybe treat as if stdin -- return results to stdout
- return multiple results from applying a match
- edge queries
- meta queries (crazy aunts):  ?^G ?^S ?^N ?^D    (grammar, stats, net, sync)

10. persistence - ikea() idea seems ok
- deal with container updates (11.)

11. container updates
- requires:
  1. reading in previous contents
  2. verify that content matches contenthash (optional, maybe)
  3. updating,
  4. saving and  computing new contentx hash
  5. updating contentx hash in containing object
  6. removing old contents iff no nonger referenced

12. Multi-threading, multi-process forking. Separate threads/processes for:
	- layout computation
	- container reloading for update
    - Need Locking strategt - (Mutex code?)
    -- Need lock for access to session
    -- Does it need lock to round-robin reads from multiple input streams?
    -- Does it need lock to read container content from ikea before continuong?

13. distributed graphs
  - net is a graph of authorized ssh access,  
  -    authorization may be symmetric: either end can intiate ssh
                        or asymmetric: only one end can initiate
  - access to authorized host needs to be verfied periodically,
      and indications made to the graph at both ends if access is broken 
      -- any normal RESTful connection can be used as verification
         polling only need in absence of normal traffic

  - access authorizations are at the user level, so avalable to 
    all g process run by that user

  - each g process may use all or any subset of the authorized access
    in its graph, (or graphs?)

       (a polling strategy is implied for assymetric accees)
  - actual connections are short RESTful connections over ssh.

    - no graph concept of read-only -  if the access is authorized
    (symmetric or asymetric) then both sides see the same distributed graph


14. g_pretty with opt for degrees of ecpansion and indentation

15. Use SHORTSTR to replace FRAGLISTs whenever string length is short enough
    (Optimization of shorage and key matching in trees)
PARTIALLY DONE - double frees elems

16. Meta graphs:
      - grammar - Aunt Gudrun - devine knowledge
      - sync - Aunt Maude (the crazy one, believes anything, remembers nothing)
                ( or Aunt Dottie)
      - net - Aunt Nettie
      - cron - Aunt Cadence
      - stats  - Aunt Sally (with tribute to my Sister ;-)
                - also include version info.

      - graph - maybe no name
           -- nodes + attributes + edges?
           -- edges + attributes
           -- patterns

17. THREAD stats  (maybe add to SESSION stats?)
DONE. THREAD and SESSION have been broken out and stats divided accoringly.

18. Extend grammar to enforce NOUNSET members to be all NODEs or all EDGEs
TRIED but FAILED ...

19. Try to eliminate elements like VALASSIGN
        ATTR ATTRID ABC abc
             VALASSIGN EQL
                       VALUE ABC xyz
    during state exit processing in grammar.c, to:
        ATTR ATTRID ABC abc
             VALUE ABC xyz 
DONE - see state exit code in graph.c

20. Error recovery ( something less that FATAL on input errors )

    - return last good ACT in warning message ...
    - sender does what?
   or
    - QRY  (ask dottie) - gets ACT number of QRY, and id to match QRY itself
    - report last good ACT by ACT number

            
21. may need EDGE trees per NODE to support navigational queries
