1. fix elem leaks 
DONE currenly fixed, + added assert to immediately detect new leaks

2. attribute trees,  attribute merging

3. need some kind of print_edge_name
- for compare and for ikea ...
- needs logical space between str elems, and between legs and disambig
-- maybe insert real: < > `

4. breakout PARSE_t from CONTEXT_t
WIP - this part is done - still working on a THREAD SESSION split

5. common match code for patterns and queries

6. extend match patterns
- currently ABC* matching only
- would be nice to have support for: *ABC   and ABC*XYZ
- can we find a syntax for REs that fits?

7. parent{graph patterns stats cron net...}

8. thread and event model
- parser per thread
- allow multiple ACTIVITY streams per parser (ACTS treated atomically)
- inotify input events
  - on last non-stdin file on command line?
  - on file with special option ?
  - RESTful events on a socket  (push or pull) - a daemon mode
- cron-like:
	 output events e.g. "cron{^/graph[full=nowtime%3600 diff=nowtime%5]}"
-        input polling events, ....
         access verication...

- gdiff - for incremental outputs

9. queries
- results return to same bidir channel (RESTfull, socket, stdio, 
            -- what about queries in files??? 
                     -- maybe treat as if stdin -- return results to stdout
- return multiple results from applying a match
- edge queries
- meta queries:  ?^g ?^p  ?^s  ?^n    (graph, patterns, stats, net)

10. persistence - ikea() idea seems ok
- deal with container updates (11.)

11. container updates
- requires:
  1. reading in previous contents
  2. updating,
  3. saving and  computing new content hash
  4. updating content hash in containing object
  5. removing old contents iff no nonger referenced

12. ?? separate threads/processes for:
	- layout computation
	- container reloading for update

13. distributed graphs
  - net is a graph of authorized ssh access,  
  -    authorization may be symmetric: either end can intiate ssh
                        or asymmetric: only one end can initiate
  - access to authorized host needs to be verfied periodically,
      and indications made to the graph at both ends if access is broken 
      -- any normal RESTful connection can be used as verification
         polling only need in absence of normal traffic

  - access authorizations are at the user level, so avalable to 
    all g process run by that user

  - each g process may use all or any subset of the authorized access
    in its graph, (or graphs?)

       (a polling strategy is implied for assymetric accees)
  - actual connections are short RESTful connections over ssh.

    - no graph concept of read-only -  if the access is authorized
    (symmetric or asymetric) then both sides see the same distributed graph


14. g_pretty with opt for degrees of ecpansion and indentation

15. Use SHORTSTR to replace FRAGLISTs whenever string length is short enough
    (Optimization of shorage and key matching in trees)

16. Meta graphs:
      - grammar
      - graph
           -- nodes
           -- edges
           -- patterns
      - net
      - cron
      - stats 

17. THREAD stats  (maybe add to SESSION stats?)

18. Extend grammar to enforce NOUNSET members to be all NODEs or all EDGEs

19. Try to eliminate elements like VALASSIGN
        ATTR ATTRID ABC abc
             VALASSIGN EQL
                       VALUE ABC xyz
    during state exit processing in grammar.c, to:
        ATTR ATTRID ABC abc
             VALUE ABC xyz 


            
