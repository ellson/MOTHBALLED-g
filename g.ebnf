# A graph structure is built incrementally with a series of <acts>.
# There is no hard beginning or end, permitting any "graph" to be interpreted in the context
# of any other graph,  where it may be used prepended, appended, or contained.

                <act> ::= <action>? <subj_prop_cont> <term>?

     <subj_prop_cont> ::= <nodesubject> <nodeproperties>? <nodecontents>?
                        | <edgesubject> <edgeproperties>? <edgecontents>?
                        
# The default <action> is to add (or, to add to) a <nodesubject> or <edgesubject>, '~' signals deletion

             <action> ::= '~'

# The <term> is mostly optional since it is rarely needed.
# It serves two purposes.
#   1) for people that like to end statements with a terminator.
#   2) for when a stream of <act>s stop, to indicate that the
#      last <act> is finished. Normally in a stream, an <act> is adequately
#      syntactically terminated when the next <act> starts. but while the
#      stream is stopped the last <act> gets stuck, unless forced out with
#      a <term>.  Think of it like a "flush" operator.
# An <EOF> condition on the input stream is implicitly a <term>.

               <term> ::= ';'

# A <nodesubject> of an <act> is one or more <node>, or future <node> that match a pattern

        <nodesubject> ::= <node>
                        | <nodelist>
                        | <nodepatternlist>

# A <node> can be simple, or multi (think "stacks" of node, all in the same
# place, all with the same <properties>, all with the same <contents>)

               <node> ::= <node_name> <disambiguator>?
          <node_name> ::= <simple_string>
      <disambiguator> ::= '::' <simple_string>

           <nodelist> ::= '(' <node>+ ')'

# <nodepatternlist> are stored, and can be deleted, but they are not rendered
# directly. They introduce <nodeproperties> and <nodecontents> to be
# automatically added to a <node> of any following <act> in the current container that
# match any member of the <nodepatternlist>.

# When a <nodepatternlist> is deleted, no further <node> are modified,
# but all current modifications from the <nodepattern> remain.

    <nodepatternlist> ::= '(' <node>? <nodepattern>+ <node_or_pattern>? ')' 

    <node_or_pattern> ::= <node>
                        | <nodepattern>

        <nodepattern> ::= ... Like <node> but with at least one '*' in:
                              or <node_name>,
                              or <discriminator>.   ...

# An <edgesubject> of an <act> is one or more <edge>, or future <edge> that match a pattern

        <edgesubject> ::= <edge>
                        | <edgelist>
                        | <edgepatternlist>

# An <edge> can be simple, or multi (think "parallel" edges, all with the
# same <endpoints> (modulo disambiguation), all with the same <properties>,
# all with the same <contents>)

# An <edge> can be fully contained in the current container, or one or more
# of it endpoints can be in another container, descibed by a path relative
# to the current container.

# <edges> can induce <node> and all <descendent> <container> implied by the path to the <node>.
# <ancestor> <contained_by> must exist.

               <edge> ::= '<' <endpoints> '>' <disambiguator>?

          <endpoints> ::= <endpoint> <endpoint>+

           <endpoint> ::= <ancestor>? <decendent>? <localendpoint>

           <ancestor> ::= <contained_by>+

          <contained_by> ::= ':' '/'

         <descendent> ::= <container>+

          <container> ::= <container_name> '/'

     <container_name> ::= <node>
                        | <edge>

      <localendpoint> ::= <node_port>
                        | <container_port> 

          <node_port> ::= <node> <port>?

     <container_port> ::= <port>

               <port> ::= ':' <port_name>

# if <port> is not provided for a <node_port> then it defaults to the
# center of the shape, with the line representing the <edge> clipped back
# to the boundary of the shape.

           <edgelist> ::= '(' <edge>+ ')'
                        | '<' <endpoint>? <endpointlist> <endpoint_or_list>+ '>'

       <endpointlist> ::= '(' <endpoint> ')'

   <endpoint_or_list> ::= <endpoint>
                        | <endpointlist>

# Note:  <(a b) c>  is equivalent to:  (<a c> <b c>)

# <edgepatternlist> are stored, and can be deleted, but they are not rendered
# directly. They introduce <edgeproperties> and <edgecontents> to be
# automatically added to a <edge> of any following <act> in the current container that
# match any member of the <edgepatternlist>.

# When a <edgepatternlist> is deleted, no further <edge> are modified,
# but all current modifications from the <edgepattern> remain.

    <edgepatternlist> ::= '(' <edge>* <edgepattern>+ <edge_or_pattern>* ')' 
                        | '<' <endpoint_or_list> <endpointpatternlist> <endpoint_or_list>* '>' <disambiguator>?

    <edge_or_pattern> ::= <edge>
                        | <edgepattern>

        <edgepattern> ::= '<' <endpoint_or_patternlist> <endpointpatternlist> <endpoint_or_patternlist>* '>' <disambiguator>?

<endpoint_or_patternlist> ::= <endpoint>
                        | <endpointpatternlist>

<endpointpatternlist> ::= '(' <endpointpattern> ')'

    <endpointpattern> ::= ... Like <endpoint> but with at least one '*' in:
                              <container_name>,
                              or <node_name>,
                              or <port_name>,
                              or <disambiguator>.   ...

# Any <nodesubject> can have <nodeproperties>  and <nodecontents> which are to be
# added (or deleted) from all the <node> implied by the <nodesubject>

# <nodeproperties> represent properties of the <node> outside of any container it might have.
# think attributes like labels and shapes.

# If a <value> is not provided then it defaults to the empty string, the interpretation of which is left undefined
# by this syntax, and may be interpreted in different ways in differerent attributes.

     <nodeproperties> ::= '[' <nodeattribute_value>+ ']'

<nodeattribute_value> ::= <nodeattribute> <value_assign>?

      <nodeattribute> ::= <string>

       <value_assign> ::= '=' <value>

              <value> ::= <string>
                        | <integer>
                        | <float>
                        | <boolean>

# <nodecontents> consist of a set of properties for the inside of the container (think layout_engine)
# and a contained "graph" using <act> recursively.

       <nodecontents> ::= '{' <containerproperties>? <act>+ '}'

<containerproperties> ::= '[' <containerattribute_value>+ ']' <term>?

<containerattribute_value> ::= <containerattribute> <value_assign>?

# There is no top-level container, other than the interpreting program itself
# so top-level layout properties must come from the program or its command line options. 

# Any <edgesubject> can have <edgeproperties> and/or <edgecontents> which are to be
# added (or deleted) from all the <edge> implied by the <edgesubject>

# If <value> is not provided then it defaults to assigning the empty string 

# The sytax of <edgeproperties>, <nodeproperties>, and <containerproperties> is identical,
# but separate run-time disctionaries are used for each.

     <edgeproperties> ::= '[' <edgeattribute_value>+ ']'

<edgeattribute_value> ::= <edgeattribute> <value_assign>?

      <edgeattribute> ::= <string>

       <edgecontents> ::= '{' <containerproperties>? <act>+ '}'

# An <edge> is a relationship between a set of two or more <node>s, or more
# stricly, <port>s. A <port> is a named-place on the outside of a <node>,
# and also, if the <obj> has <contents>, then it is a named-place refered to
# from inside the container.

# If the containing <obj> is a <node>  then the external name is, e.g. "A:w"
# ( the west compass port on node "A" ).  The internal name for that same port 
# is just ":w"

# If the containing object is an <edge>  then the external name is the
# <node> at the external end of the <edge>.  The internal name for that
# same port is the 1-based index of the <node> in the containing <edge>'s
# name.  i.e the "leg" number.
# This may seem awkward, but it allows the edge's <content> to be reused
# for multiple edges.

# Note that for <edge>s drawn as lines, the internal <port> and the <edge>'s
# endpoint on an external <node>'s <port> are typically not in the same place.
# However, they are logically the same, since the drawing can always be
# distorted so that they are the same point with no change in semantics.

# <port_name> can be: compass points, or leg index,  or cell index.
          <port_name> ::= 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'nw'
                        | <leg_index>
                        | <cell_index>

           <leg_index> ::= <digit>+

          <cell_index> ::= <digit>+ '.' <digit>+

# Finally, <string> (Note that only quoted strings can be empty)

             <string> ::= <simple_char>+
                        | ''' <singlequoted_char>* '''
                        | '"' <doublequoted_char>* '"'

        <simple_char> ::= <not_special_char>
                        | <escape> <special_char>
                        | <escape> '''
                        | <escape> '"'
                        | <escape> <escape>

  <singlequoted_char> ::= <not_special_char>
                        | <special_char>
                        | '"'
                        | <escape> '''
                        | <escape> <escape>
                        
  <doublequoted_char> ::= <not_special_char>
                        | <special_char>
                        | '''
                        | <escape> '"'
                        | <escape> <escape>
                        
             <escape> ::= '\'

# Note:  A few <alpha_uppercase> characters, when escaped, are used
# as substitution variables:
#
#  \O is the name of the object
#  \C is the name of the containing object
#
# Any other character that is escaped, but which doesn't normally need
# to be escaped, is taken as itself.

   <not_special_char> ::= <alpha_uppercase>
                        | <alpha_lowercase>
                        | <digit>
                        | '_' | '%'
                        | '.' | ','
                        | '-' | '+'
                        | '&' | '^'
                        | '$' | '@'
                        | '!' | '|'
                        | '`' | '?'

    <alpha_uppercase> ::= A...Z
    <alpha_lowercase> ::= a...z
              <digit> ::= 0...9

       <special_char> ::= <whitespace> | <newline>
                        | '{' | '}'
                        | '(' | ')'
                        | '[' | ']'
                        | '<' | '>'
                        | '~' | '='
                        | ':' | ';'
                        | '/' | '#'
                        | '*'

           <comments> ::= '//' ... EOL
                        | '#' ... EOL
                        | '/*' ... '*/'

# Note that  '+' '-' '.' ','  Are not special.  So numbers 
# are usable as simple strings in names and values.

# FIXME - do we want a restricted form of ID for node names and attribute names?

# FIXME - additional detail needed for html-like label strings....

