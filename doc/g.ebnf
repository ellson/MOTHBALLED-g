# The g language is used for describing graphs of nodes and edges.

# The g language is unusual in that there are no keywords in the language,  only key characters (and a few character pairs)
# all of which are non-alpanumeric.  Consequently, strings only need quoting if they contain whitespace, or a special
# character, and escaping is only needed for the quote character in quoted strings.

# Numbers are not used by the language, and so numbers (int, decimal, signed or unsigned) are all legal strings without
# quoting.  (Attibute values can be interpreted as numbers later; they are just not treated differently by the parser.)

# A graph structure is built incrementally with a series of <acts>.
#
# There is no hard begining or end, permitting any "graph" to be interpreted in the context
# of any other graph,  where it may be used, prepended or appended by the graph, or contained in one of its nodes or edges..

                <act> ::= <action>? <subject> <properties>? <contents>? <term>?

# The default <action> is to add a, or to add to an existing, <subject>. '~' signals deletion

             <action> ::= '~'

# The <term> is mostly optional since it is rarely needed.
# It serves two purposes.
#   1) for people that like to end statements with a terminator.
#   2) for when a stream of <act>s stop, to indicate that the
#      last <act> is finished. Normally in a stream, an <act> is adequately
#      syntactically terminated when the next <act> starts. but while the
#      stream is stopped the last <act> gets stuck, syntacticaly, unless forced out with
#      a <term>.  Think of it like a "flush" operator.
# An <EOF> condition on the input stream is implicitly a <term>.

               <term> ::= ';'

# A <subject> of an <act> is one <object>, or a homogonous list of <object>s of the same type.

            <subject> ::= <object>
                        | '(' <object>+ ')'

             <object> ::= <node> 
			| <edge>

# A <node> can be simple, or multi (think "stacks" of node, all in the same
# place, all with the same <properties>, all with the same <contents>)

               <node> ::= <node_id> <disambiguator>?
            <node_id> ::= <string>
      <disambiguator> ::= '::' <disambiguator_id>
   <disambiguator_id> ::= <string>

# An <edge> can be simple, or multi (think "parallel" edges, all with the
# same <endpoints> (modulo disambiguation), all with the same <properties>,
# all with the same <contents>)

# An <edge> can be fully contained in the current container, or one or more
# of it endpoints can be in another container, descibed by a path relative
# to the current container.

# <edge> can induce <node>s

               <edge> ::= '<' <tail> <head>+ '>' <disambiguator>?

		<tail> ::= <endpoint>
			| '(' <endpoint> ')'

		<head> ::= <endpoint>
			| '(' <endpoint> ')'

# Note: The construct:  <(a b) z>
#    is equivalent to:  (<a z> <b z>)

           <endpoint> ::= <ancestor>? <decendent>? <localendpoint>

           <ancestor> ::= ':/'

         <descendent> ::= <obj> '/'

      <localendpoint> ::= <node> <port>?
                        | <port>

               <port> ::= ':' <port_id>

# Note: a <port> as a <localendpoint> refers the inside <port> on the <container>
# in which the <endpoint> is in.  For <node> contents it uses the same <port_id>
# inside as outside.  For <edge> contents it refers a particular <tail>
# or <head> of the parent <edge> by means of an index: 1=<tail>, 2,3,4...=<head>s.

# If <port> is not provided for a <node_port> then it defaults to the
# center of the shape, with the line representing the <edge> clipped back
# to the boundary of the shape.

# Any <subject> can have <properties> and <contents> which are to be
# added (or deleted) from the <object> or <object>s specified by the <subject>

# <properties> of a <subject> affect the outside of any container it might have.
# Think attributes like labels and shapes.

# <container>s have an additional set of <properties> for describing the inside of the <container>
# Think: layout engine,  graph/digraph, strict/nonstrict, ...

# There is no <container> for the top <act>s, so its properties must be
# provided by the external environment, such as from the command line.

# If a <value> is not provided then it defaults to the empty string, the interpretation of which is left undefined
# by this syntax, and may be interpreted in different ways in differerent attributes.

         <properties> ::= '[' <attribute_value>* ']'

    <attribute_value> ::= <attribute_id> <value_assign>?

       <attribute_id> ::= <string>

       <value_assign> ::= '=' <value>

              <value> ::= <string>

# <contents> consist of: a set of properties for the inside of the container (think layout_engine)
# followed by: a contained "graph" using <act> recursively.

           <contents> ::= '{' <properties>? <act>* '}'

# Finally, <string> (Note that only quoted strings can be empty)

             <string> ::= <simple_char>+
                        | ''' <singlequoted_char>* '''
                        | '"' <doublequoted_char>* '"'
                        | '<' <html_like_char>* '>'

  <singlequoted_char> ::= <simple_char>
                        | <special_char>
                        | <angles>
                        | '"'
                        | <escape> '''     
                        | <escape> <escape>
                        
  <doublequoted_char> ::= <simple_char>
                        | <special_char>
                        | <angles>
                        | '''
                        | <escape> '"'
                        | <escape> <escape>
                        
     <html_like_char> ::= <simple_char>
                        | <special_char>
                        | '''
                        | '"'
                        | <angles>              .... '<', '>', must be balanced ...
                        
             <escape> ::= '\'

# Note:  A few <alpha_uppercase> characters, when escaped, are used
# as substitution variables:
#
#  \O is the name of the object
#  \C is the name of the containing object
#
# Any other character that is escaped, but which doesn't normally need
# to be escaped, is taken as itself.

        <simple_char> ::= <alpha_uppercase>
                        | <alpha_lowercase>
                        | <digit>
                        | '_' | '%'
                        | '.' | ','
                        | '-' | '+'
                        | '&' | '^'
                        | '$' | '@'
                        | '!' | '|'
                        | '`' | '?'
			| \200 ... \377

    <alpha_uppercase> ::= A...Z
    <alpha_lowercase> ::= a...z
              <digit> ::= 0...9

             <angles> ::= '<' | '>'

       <special_char> ::= <whitespace> | <newline>
                        | '{' | '}'
                        | '(' | ')'
                        | '[' | ']'
                        | '~' | '='
                        | ':' | ';'
                        | '/' | '#'    ... only special because of comments ...
                        | '*'

           <comments> ::= '//' ... EOL
                        | '#' ... EOL
                        | '/*' ... '*/'

# Note that  '+' '-' '.' ','  Are not special.  So numbers 
# are usable as simple_strings in names and values.

# FIXME - patterns
